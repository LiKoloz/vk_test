package main

import (
	"fmt"
	"math/rand"
	"net/http"
	"strconv"
	"strings"
	"time"
	. "vk/Announcement/models"
	. "vk/Announcement/repository"
	. "vk/User/models"
	. "vk/User/services"

	"github.com/go-playground/validator"
	"github.com/labstack/echo/v4"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"

	_ "vk/docs" // docs is generated by Swag CLI, you have to import it.

	"github.com/golang-jwt/jwt/v5"
	echojwt "github.com/labstack/echo-jwt/v4"

	echoSwagger "github.com/swaggo/echo-swagger"
)

// @title Swagger Example API
// @version 1.0
// @description This is a sample server Petstore server.
// @termsOfService http://swagger.io/terms/

// @contact.name API Support
// @contact.url http://www.swagger.io/support
// @contact.email support@swagger.io

// @license.name Apache 2.0
// @license.url http://www.apache.org/licenses/LICENSE-2.0.html

// @host petstore.swagger.io
// @BasePath /v2

func main() {
	dsn := "host=db user=postgres password=123 dbname=vk port=5432 sslmode=disable TimeZone=Europe/Moscow"
	db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{})

	if err != nil {
		panic("Error to connect DB!")
	} else {
		fmt.Println("Db connect ready!")
	}

	db.AutoMigrate(&User{})
	db.AutoMigrate(&Announcement{})

	GenerateMockData(db)

	e := echo.New()
	e.Validator = &CustomValidator{validator: validator.New()}

	e.GET("/swagger/*", echoSwagger.WrapHandler)

	// Регистрация пользователя
	// @Summary Register a new user
	// @Description Create a new user account
	// @ID user-registration
	// @Accept  json
	// @Produce  json
	// @Param   user body UserDTO true "User registration data"
	// @Success 200 {object} User
	// @Failure 400 {string} string "Bad request"
	// @Router /user/registration [post]
	e.POST("user/registration", func(c echo.Context) error {

		u := new(UserDTO)
		if err = c.Bind(u); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, err.Error())
		}
		if err = c.Validate(u); err != nil {
			return err
		}
		_, err := Registration(db, u.Login, u.Password)
		if err != "" {
			return c.JSON(http.StatusBadRequest, err)
		}

		jwt, err2 := generateSimpleJWT()
		if err2 != nil {
			return c.JSON(http.StatusBadRequest, err)
		}

		return c.String(http.StatusOK, jwt)
	})

	e.GET("/swagger/*", echoSwagger.WrapHandler)

	e.Use(echojwt.WithConfig(echojwt.Config{
		SigningKey: jwtSecret,
		Skipper: func(c echo.Context) bool {
			return strings.HasPrefix(c.Path(), "/swagger") ||
				strings.HasPrefix(c.Path(), "/user/registration") ||
				strings.HasPrefix(c.Path(), "/user/sign_in")
		},
	}))

	// Получение объявлений по дате создания (ASC)
	// @Summary Get announcements sorted by creation date (ascending)
	// @Description Get paginated list of announcements sorted by creation date
	// @ID get-announcements-by-date
	// @Produce  json
	// @Param   uid path int true "User ID"
	// @Param   page path int true "Page number"
	// @Success 200 {array} Announcement
	// @Failure 400 {string} string "Bad request"
	// @Router /announcement/get/create_at/{uid}/{page} [get]
	e.GET("announcement/get/create_at/:uid/:page", func(c echo.Context) error {
		page, err := strconv.Atoi(c.Param("page"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad page")
		}

		uid, err := strconv.Atoi(c.Param("uid"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad page")
		}

		announcements, err := GetPaginationCreateAt(db, page, uint(uid))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad request")
		}
		return c.JSON(http.StatusOK, announcements)
	})

	// Получение объявлений по дате создания (DESC)
	// @Summary Get announcements sorted by creation date (descending)
	// @Description Get paginated list of announcements sorted by creation date descending
	// @ID get-announcements-by-date-desc
	// @Produce  json
	// @Param   uid path int true "User ID"
	// @Param   page path int true "Page number"
	// @Success 200 {array} Announcement
	// @Failure 400 {string} string "Bad request"
	// @Router /announcement/get/create_at/desc/{uid}/{page} [get]
	e.GET("announcement/get/create_at/desc/:uid/:page", func(c echo.Context) error {
		page, err := strconv.Atoi(c.Param("page"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad uid")
		}

		uid, err := strconv.Atoi(c.Param("uid"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad page")
		}

		announcements, err := GetPaginationCreateAt(db, page, uint(uid))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad request")
		}
		return c.JSON(http.StatusOK, announcements)
	})

	// Получение объявлений по цене (ASC)
	// @Summary Get announcements sorted by price (ascending)
	// @Description Get paginated list of announcements sorted by price
	// @ID get-announcements-by-price
	// @Produce  json
	// @Param   uid path int true "User ID"
	// @Param   page path int true "Page number"
	// @Success 200 {array} Announcement
	// @Failure 400 {string} string "Bad request"
	// @Router /announcement/get/price/{uid}/{page} [get]
	e.GET("announcement/get/price/:uid/:page", func(c echo.Context) error {
		page, err := strconv.Atoi(c.Param("page"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad uid")
		}

		uid, err := strconv.Atoi(c.Param("uid"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad page")
		}

		announcements, err := GetPaginationPrice(db, page, uint(uid))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad request")
		}
		return c.JSON(http.StatusOK, announcements)
	})

	// Получение объявлений по цене (DESC)
	// @Summary Get announcements sorted by price (descending)
	// @Description Get paginated list of announcements sorted by price descending
	// @ID get-announcements-by-price-desc
	// @Produce  json
	// @Param   uid path int true "User ID"
	// @Param   page path int true "Page number"
	// @Success 200 {array} Announcement
	// @Failure 400 {string} string "Bad request"
	// @Router /announcement/get/price/desc/{uid}/{page} [get]
	e.GET("announcement/get/price/desc/:uid/:page", func(c echo.Context) error {
		page, err := strconv.Atoi(c.Param("page"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad uid")
		}

		uid, err := strconv.Atoi(c.Param("uid"))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad page")
		}

		announcements, err := GetPaginationPriceAtDesc(db, page, uint(uid))
		if err != nil {
			return c.String(http.StatusBadRequest, "Bad request")
		}
		return c.JSON(http.StatusOK, announcements)
	})

	// Создание объявления
	// @Summary Create a new announcement
	// @Description Add a new announcement to the system
	// @ID create-announcement
	// @Accept  json
	// @Produce  json
	// @Param   announcement body AnnouncementDTO true "Announcement data"
	// @Success 200 {object} Announcement
	// @Failure 400 {string} string "Bad request"
	// @Router /announcement/create [post]
	e.POST("announcement/create", func(c echo.Context) error {
		a := new(AnnouncementDTO)
		if err = c.Bind(a); err != nil {
			return echo.NewHTTPError(http.StatusBadRequest, err.Error())
		}
		if err = c.Validate(a); err != nil {
			return err
		}
		fmt.Println(a.UserRefer)
		res, err := AddAnnouncement(db, Announcement{
			Title:     a.Title,
			Text:      a.Text,
			Image:     a.Image,
			Price:     a.Price,
			UserRefer: a.UserRefer,
		})
		if err != nil {
			return c.JSON(http.StatusBadRequest, err)
		}

		return c.JSON(http.StatusBadRequest, res)
	})

	// Вход пользователя
	// @Summary User sign in
	// @Description Authenticate user and get user details
	// @ID user-sign-in
	// @Produce  json
	// @Param   login path string true "User login"
	// @Param   password path string true "User password"
	// @Success 200 {object} User
	// @Failure 400 {string} string "Invalid credentials"
	// @Router /user/sign_in/{login}/{password} [get]
	e.GET("user/sign_in/:login/:password", func(c echo.Context) error {
		login := c.Param("login")
		password := c.Param("password")

		res, err := SignIn(db, login, password)

		if err != "" {
			return c.String(http.StatusBadRequest, err)
		}

		return c.JSON(http.StatusOK, res)
	})
	e.Logger.Fatal(e.Start(":8080"))
}

// GenerateMockData создает тестовых пользователей с объявлениями
func GenerateMockData(db *gorm.DB) {
	// Проверяем, есть ли уже данные
	var count int64
	db.Model(&User{}).Count(&count)
	if count > 0 {
		return
	}

	// Инициализация генератора случайных чисел
	rand.Seed(time.Now().UnixNano())

	// Создаем 5 пользователей
	for i := 1; i <= 5; i++ {
		user := User{
			Login:    fmt.Sprintf("user%d", i),
			Password: fmt.Sprintf("password%d", i),
		}

		db.Create(&user)

		// Создаем 3-5 объявлений для каждого пользователя
		numAnnouncements := 3 + rand.Intn(3) // От 3 до 5 объявлений
		for j := 1; j <= numAnnouncements; j++ {
			announcement := Announcement{
				Title:     fmt.Sprintf("Объявление %d-%d", i, j),
				Text:      fmt.Sprintf("Это текст объявления от пользователя %d, номер %d", i, j),
				Image:     fmt.Sprintf("image%d.jpg", j),
				Price:     float64(100*i + 10*j),
				UserRefer: user.ID,
				CreatedAt: time.Now().Add(-time.Duration(rand.Intn(30)) * 24 * time.Hour),
			}
			db.Create(&announcement)
		}
	}
}
func (cv *CustomValidator) Validate(i interface{}) error {
	if err := cv.validator.Struct(i); err != nil {
		// Optionally, you could return the error to give each route more control over the status code
		return echo.NewHTTPError(http.StatusBadRequest, err.Error())
	}
	return nil
}

type CustomValidator struct {
	validator *validator.Validate
}

var jwtSecret = []byte("secret")

func generateSimpleJWT() (string, error) {
	// Создаем стандартные claims
	claims := jwt.RegisteredClaims{
		ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
		Issuer:    "my_app",
	}

	// Создаем токен
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	// Подписываем и возвращаем оба значения
	return token.SignedString(jwtSecret)
}

func validateJWT(tokenString string) (bool, *jwt.RegisteredClaims, error) {
	token, err := jwt.ParseWithClaims(
		tokenString,
		&jwt.RegisteredClaims{},
		func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
			}
			return jwtSecret, nil
		},
	)

	if err != nil {
		return false, nil, fmt.Errorf("token validation failed: %w", err)
	}

	if claims, ok := token.Claims.(*jwt.RegisteredClaims); ok && token.Valid {
		return true, claims, nil
	}

	return false, nil, fmt.Errorf("invalid token")
}
